package utils;
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.io.Reader;
import java.io.StringReader;
import java.util.HashMap;
import java.util.regex.Pattern;
/**
 * should be able to handle most files generated by XML editors.  to use, override the dispatch
 * method and call processFile(fname).  dispatch(), in turn, should call processNextChunk and return
 * an object as appropriate depending on the tag of the current chunk.
 * @author adk
 *
 */
public abstract class FakeXMLProcessor{
	public static String XML_MUMBO_JUMBO = "<?xml version=\"1.0\" encoding=\"ISO-8859-1\"?>\n";
	
	private int lineCounter = 0;
	private String fileN = "";
	public int getLineNumber(){
		return lineCounter;
	}
	public void setLineCounter(int lc){
		lineCounter = lc;
	}
	public String getFileName(){
		return fileN;
	}
	
	public Object processFile(String fileName){
		fileN = fileName;
		try{
			BufferedReader in = new BufferedReader(new FileReader(fileName));
			String sentence, markup;
			lineCounter = 0;
			Object[] res = processNextChunk(in);
			if(res!=null)return res[1];
			else return null;
		} catch(IOException f){
			Mark.say("Caught IOException while processing "+fileName+".");
			//Mark.say(f);
		}
		return null;
	}
	
	public Object processReader(Reader in,int lineC){
		fileN = "input-stream";
		try{
			lineCounter = lineC;
			Object[] res = processNextChunk(in);
			if(res!=null)return res[1];
			else return null;
		} catch(IOException f){
			Mark.say("Caught IOException while processing "+fileN+".");
			Mark.say(f);
		}
		return null;
	}
	
	public Object processReader(Reader in){
		return processReader(in,0);
	}
	
	public Object processString(String s){
		return processReader(new StringReader(s),0);
	}
	public Object processString(String s,int line){
		return processReader(new StringReader(s),line);
	}
	
	/**
	 * process the next chunk in the current stream, per user-define method dispatch()
	 * 
	 * @param in  the stream to read from
	 * @return a {key,value} array or null
	 * @throws IOException
	 */
	protected Object[] processNextChunk(Reader in) throws IOException{
		if(ready(in)){
			String tagLine = getFirstTag(in);
			if(tagLine==null)return null;
			String meat = getUntilClose(in,tagLine);
			lineCounter -= numLines(meat);
			Reader sr = new BufferedReader(new StringReader(meat));
            //System.err.println("Mark AAA: " + meat);
            //System.err.println("Mark BBB: " + tagLine);
			Object soup = dispatch(sr,tagLine);
			if(soup==null)return null;
			return new Object[]{tagLine,soup};
		}else return null;
	}
	
	private int numLines(String s){
		int j=0;
		for(int i=0;i<s.length();i++){
			if(s.charAt(i)=='\n')j++;
		}
		return j;
	}
	
	private String getUntilClose(Reader in, String tagLine) throws IOException{
		HashMap<String,Integer> tagCounts = new HashMap<String,Integer>();
		tagCounts.put(tagLine, 1);
		String chunk = "";
		String top   = "";
		while(ready(in)){
			String readc = readChar(in);
			if(readc==null)break;
			else top += readc;
			if(isOpenComment(top)){
				top = "";
				eatXMLComment(in);
			}
			else if(isXMLVoodoo(top)){
				top = "";
				eatXMLVoodoo(in);
			}
			if(isOpenTag(top)){
				if(tagCounts.containsKey(getTagLabel(top))){
					tagCounts.put(getTagLabel(top), tagCounts.get(getTagLabel(top))+1);
				}else{
					tagCounts.put(getTagLabel(top), 1);
				}
				chunk += top;
				top = "";
			}else if(isCloseTag(top)){
				if(tagCounts.containsKey(getTagLabel(top))){
					tagCounts.put(getTagLabel(top), tagCounts.get(getTagLabel(top))-1);
				}else{
					tagCounts.put(getTagLabel(top), -1);
				}
				if(isZeroed(tagCounts)){
					return chunk;
				} else {
					chunk += top;
					top = "";
				}
			} else if(!isValidPartialTag(top)){
				chunk += top;
				top = "";
			}
			if(!isConsistent(tagCounts)){
				Mark.say("probably bad markup syntax near line "+lineCounter+" in file "+fileN);
			}
		}
		Mark.say("no end tag near line "+lineCounter+" in file "+fileN);
		return chunk;
	}
	private boolean isConsistent(HashMap<String,Integer> h){
		for(Integer i:h.values()){
			if(i<0)return false;
		}
		return true;
	}
	private boolean isZeroed(HashMap<String,Integer> h){
		for(Integer i:h.values()){
			if(i!=0){
				return false;
			}
		}
		return true;
	}
	
	/**
	 * this is just for processing tags. override and call processNextChunk to get 
	 * nested objects, yadda yadda yadda.
	 * 
	 * @param in a reader for the current chunk
	 * @param tagLine the tag surrounding the current chunk indicating its type
	 * @return an object generated from the current chunk if applicable or null
	 * @throws IOException
	 */
	protected abstract Object dispatch(Reader in,String tagLine) throws IOException ;
		
	
	
	
	
	
	private String getFirstTag(Reader in) throws IOException{
		String partial = "";
		while(ready(in)){
			String readc = readChar(in);
			if (readc==null)break;
			else partial += readc;
			if(isOpenComment(partial)){
				partial = "";
				eatXMLComment(in);
			}
			else if(isXMLVoodoo(partial)){
				partial = "";
				eatXMLVoodoo(in);
			}
			else if(isOpenTag(partial)){
				return getTagLabel(partial);
			}
			else if(isCloseTag(partial)){
				Mark.say("unexpected close-tag near line "+lineCounter+" in file "+fileN);
				throw new IOException();
			} else if(!isValidPartialTag(partial)){
				partial = "";
			}
		}
		return null;
	}
	
	/**
	 * read a char and return a string with that character only or null if we met the end
	 * of the stream.
	 * 
	 * @param in
	 * @return
	 * @throws IOException
	 */
	protected String readChar(Reader in) throws IOException{
		int c = in.read();
		if (c == '\n'){
			lineCounter++;
		}
		return (c==-1)?null:String.valueOf((char)c);
	}
	
	protected String getString(Reader in) throws IOException{
		String s = "";
		while(ready(in)){
			String readc = readChar(in);
			if (readc==null)break;
			else s += readc;
		}
		return unescape(s);
	}
	
	private boolean isOpenTag(String input){
		input = input.trim();
		return (input.matches("<[^/]*>"));
	}
	private boolean isCloseTag(String input){
		input = input.trim();
		return input.matches("</.*>");
	}
	private boolean isXMLVoodoo(String input){
		input = input.trim();
		return input.matches("<\\?");
	}
	private boolean isOpenComment(String input){
		input = input.trim();
		return input.matches("<!--");
	}
	private boolean isValidPartialCloseXMLVoodoo(String input){
		input = input.trim();
		return input.matches("\\?");
	}
	private boolean isValidPartialCloseXMLComment(String input){
		input = input.trim();
		return input.equals("-")||input.equals("--");
	}
	private boolean isCloseXMLVoodoo(String input){
		input = input.trim();
		return input.equals("?>");
	}
	private boolean isCloseXMLComment(String input){
		input = input.trim();
		return input.equals("-->");
	}
	private boolean isValidPartialTag(String input){
		input = input.trim();
		return input.matches("<[^<]*");
	}
	private void eatXMLVoodoo(Reader in) throws IOException{
		String partial = "";
		while(ready(in)){
			String readc = readChar(in);
			if (readc==null)break;
			else partial += readc;
			if(isOpenComment(partial)){
				Mark.say("malformed XML? (xml comment inside xml voodoo near line "+lineCounter+" of file "+fileN);
				eatXMLComment(in);
				partial = "";
			}
			else if(isXMLVoodoo(partial)){
				Mark.say("malformed XML? (nested xml voodoo near line "+lineCounter+" of file "+fileN);
				eatXMLVoodoo(in);
				partial = "";
			}
			else if(isCloseXMLVoodoo(partial)){
				return;
			}
			else if(!isValidPartialCloseXMLVoodoo(partial)){
				partial = "";
			}
		}
		//System.out.println("mark 1");
		throw new IOException("couldn't swallow the folowing XML Voodoo: <?"+partial);
	}
	private void eatXMLComment(Reader in) throws IOException{
		String partial = "";
		while(ready(in)){
			String readc = readChar(in);
			if (readc==null)break;
			else partial += readc;
			if(isOpenComment(partial)){
				Mark.say("malformed XML? (xml comment inside xml comment near line "+lineCounter+" of file "+fileN);
				eatXMLComment(in);
				partial = "";
			}
			else if(isXMLVoodoo(partial)){
				Mark.say("malformed XML? (nested xml voodoo near line "+lineCounter+" of file "+fileN);
				eatXMLVoodoo(in);
				partial = "";
			}
			else if(isCloseXMLComment(partial)){
				return;
			}
			else if(!isValidPartialCloseXMLComment(partial)){
				partial = "";
			}
		}
		//System.out.println("mark 2");
		throw new IOException("couldn't swallow the folowing XML comment: <!--"+partial);
	}
	private String getTagLabel(String tag){
		tag = tag.trim();
		if (isCloseTag(tag)){
			return tag.substring(2, tag.length()-1).trim();
		}
		else if (isOpenTag(tag)){
			return tag.substring(1,tag.length()-1).trim();
		}
		else Mark.err("getTagLabel called on non-tag");
		return null;
	}
	
	/**
	 * The ready() functions for the various Reader subclasses are all different and some are 
	 * downright weird.  This is a uniform ready() function for use on FileReaders, StringReaders, etc.
	 *  
	 * @param in
	 * @return
	 * @throws IOException
	 */
	protected boolean ready(Reader in) throws IOException{
		//stringreader is weird as far a ready() is concerned.  this repairs it
		in.mark(2);
		int c = in.read();
		if(c==-1)return false;
		else{
			in.reset();
			return true;
		}
	}
	private static Pattern escaper = Pattern.compile("([^a-zA-z0-9])");
    private static String escapeRE(String str) {
        String res = escaper.matcher(str).replaceAll("\\\\$1");
        if(res.equals("\\")){
        	res = "\\\\";
        }
        return res;
    }/*someday I might need this*/
    
    public static String escape(String s){
    	s = s.replaceAll("\\&", "&amp;");
    	s = s.replaceAll(">", "&gt;");
    	s = s.replaceAll("<", "&lt;");
    	s = s.replaceAll("\"", "&quot;");
    	s = s.replaceAll("'", "&apos;");
    	return s;
    }
    public static String unescape(String s){
    	s = s.replaceAll("\\&amp;", "&");
    	s = s.replaceAll("\\&gt;", ">");
    	s = s.replaceAll("\\&lt;", "<");
    	s = s.replaceAll("\\&quot;", "\"");
    	s = s.replaceAll("\\&apos;", "'");
    	return s;
    }
    
    public static String escape(Object s){
    	return escape(s.toString());
    }
    public static void main(String args[]){
    	System.out.println(escape("<\"TAG!\" you're it!>"));
    	System.out.println(unescape(escape("<\"TAG!\" you're it!>")));
    }
}
