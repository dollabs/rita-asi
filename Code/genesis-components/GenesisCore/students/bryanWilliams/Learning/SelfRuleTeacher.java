package bryanWilliams.Learning;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Queue;
import java.util.Set;
import java.util.function.Function;

import bryanWilliams.Pair;
import bryanWilliams.Util;
import frames.entities.Entity;
import frames.entities.Sequence;
import matchers.EntityMatcher;
import matchers.representations.BindingPair;
import matchers.representations.EntityMatchResult;
import utils.Mark;

public class SelfRuleTeacher {  
    private final Sequence story;
    private final Sequence commonsense;
    private final EntityMatcher matcher = new EntityMatcher();
    
    // these are the classes of bridge entities that connect predictions and explanations
    private static final Set<String> RELATION_CLASSES = new HashSet<>(Arrays.asList("classification", "relation", "social relation"));
    
    private static final Function<Entity, List<Entity>> EXTRACT_OBJECT_ENTITIES = entity -> {
        Entity obj = entity.getObject();
        if (obj.sequenceP()) {
            // apparently some objects are sequences. rare (~17/62 for macbeth), but possible
            return obj.getElements();
        }
        return Arrays.asList(obj);
    };  
    private static final Function<Entity, List<Entity>> EXTRACT_SUBJECT_ENTITIES = entity -> {
        Entity possibleExtensionSeq = entity.getSubject();
        assert possibleExtensionSeq.sequenceP();
        return possibleExtensionSeq.getElements();
    };
    private static final int MAX_CHAIN_DEPTH = 2;
    
    public SelfRuleTeacher(Sequence story, Sequence commonsense) {
        this.story = story;
        this.commonsense = commonsense;
    }
   
    /**
     * @return true iff curLeaf's reasoning chain already contains an application of
     * csRule
     */
    private boolean alreadyAppliedRule(ReasoningNode curLeaf, Entity csRule) {
        ReasoningNode curNode = curLeaf;
        while (curNode != null) {
            if (curNode.getEntity().equals(csRule)) {
                return true;
            }
            curNode = curNode.getParent();
        }
        return false;
    }
    
    /**
     * @return true iff all base entities in e are covered by a binding in bindingPairs
     */
    private boolean isFullMatch(Entity e, List<BindingPair> bindingPairs) {
        for (Entity deepEntity : Util.getAllDeepComponents(e)) {
            boolean entityIsMatched = bindingPairs.stream()
                    .anyMatch(bp -> bp.getEntities().contains(deepEntity));
            if (!entityIsMatched) {
                return false;
            }
        }
        return true;
    }
    
    /**
     * @return true iff none of the binding pairs conflict with each other
     */
    private boolean isLegalBinding(List<BindingPair> bindingPairs) {
        for (int i = 0; i < bindingPairs.size(); i++) {
            for (int j = i + 1; j < bindingPairs.size(); j++) {
                if (bindingPairs.get(i).conflictsWith(bindingPairs.get(j))) {
                    return false;
                }
            }
        }
        return true;
    }
    
    /**
     * Generates a reasoning tree by chaining reasoning as the arguments instruct
     * 
     * @param e the event to be used to root the reasoning tree
     * @param debug true iff the method should narrate its actions (print debugging output)
     * @param narrator a function that explains what the algorithm is doing with a given entity
     * @param generateLeavesToExtend a function that, given a leaf entity, generates
     * the specific parts of that leaf entity for which matches should be sought
     * @param generatePossibleExtensions a function that, given a commonsense rule,
     * generates the specific parts of that rule that should be used in matching to leaves
     * @param generatePossibleExtensionComplement a function that, given a commonsense rule,
     * generates the complement of the part of the rule used for matching (e.g. if subject
     * is used for matching, generates the object)
     * @return the root of the reasoning tree generated by chaining reasoning
     */
    private ReasoningNode chainReasoning(Entity e, Function<Entity, String> narrator, boolean debug,
            Function<Entity, List<Entity>> generateLeavesToExtend, 
            Function<Entity, List<Entity>> generatePossibleExtensions,
            Function<Entity, Entity> generatePossibleExtensionComplement) {
        ReasoningNode root = new ReasoningNode(e, null);
        
        Queue<ReasoningNode> nodeQ = new LinkedList<>();
        nodeQ.add(root);
        while (!nodeQ.isEmpty()) {
            ReasoningNode curLeaf = nodeQ.remove();
            Entity leafEntity = curLeaf.getEntity();
            Mark.say(debug, "Trying to "+narrator.apply(leafEntity));
            List<Entity> leavesToExtend;
            if (curLeaf.isRoot()) {
                leavesToExtend = Arrays.asList(leafEntity);
            } else {
                leavesToExtend = generateLeavesToExtend.apply(leafEntity);
            }
            for (Entity csRule : commonsense.getElements()) {
                if (csRule.toString().startsWith("(rel prediction (seq conjuction (rel force (ent entity")) {//-5814) (seq roles (fun object (ent action-5812))))) (fun appear (ent action-5812)))")) {
                    continue;
                }
                if (csRule.toEnglish().equals("AA because XX wants AA.")) {
                    continue;
                }
                List<Entity> possibleExtensions = generatePossibleExtensions.apply(csRule);
                for (Entity leafToExtend : leavesToExtend) {
                    for (Entity possibleExtension : possibleExtensions) {
                        boolean foundMatch = false;
                        if (alreadyAppliedRule(curLeaf, csRule)) {
                            continue;
                        }
                        EntityMatchResult matchResult = null;
                        // consider matching in both directions
                        for (EntityMatchResult curMatchResult : Arrays.asList(matcher.match(possibleExtension, leafToExtend), 
                                matcher.match(leafToExtend, possibleExtension))) {
                            foundMatch = curMatchResult.semanticMatch && isFullMatch(leafToExtend, curMatchResult.bindings)
                                    && isLegalBinding(curMatchResult.bindings);
                            if (foundMatch) {
                                matchResult = curMatchResult;
                                break;
                            }
                        }
                        if (!foundMatch) {
                            continue;
                        }
                        Mark.say(debug, "");
                        Mark.say(debug, leafToExtend.toEnglish()+" matches "+csRule.toEnglish()+" (specificially, " + 
                                possibleExtension.toEnglish()+" with bindings "+matchResult.bindings + 
                                " and score "+matchResult.score+")");
                        ReasoningNode newNode = new ReasoningNode(csRule, curLeaf, 
                                new HashSet<>(matchResult.bindings));
                        curLeaf.addChild(newNode);
                        //Mark.say(narrate, "Chain from root: ", newNode.chainFromRoot());
                        if (newNode.getDepth() < MAX_CHAIN_DEPTH) {
                            Mark.say(debug, "Now will try to "+narrator.apply(csRule));
                            Mark.say(debug, "");
                            nodeQ.add(newNode);
                        } else {
                            Mark.say(debug, "Reached max chaining depth");
                        }
                    }
                }
            }
        }
        
        return root;
    }
    
    /**
     * Returns the root of a reasoning tree generated by explaining
     * why event e would happen (backward chaining commonsense
     * rules).
     * @param e the event to be used to root the reasoning tree
     * @param debug true iff the method should narrate its actions (print debugging output)
     */
    public ReasoningNode generateExplanations(Entity e, boolean debug) {
        Function<Entity, List<Entity>> generateLeavesToExtend = EXTRACT_SUBJECT_ENTITIES;
        Function<Entity, List<Entity>> generatePossibleExtensions = EXTRACT_OBJECT_ENTITIES;
        return chainReasoning(e, 
                leafEntity -> "explain why "+leafEntity.getSubject().toEnglish(),
                debug,
                generateLeavesToExtend,
                generatePossibleExtensions,
                csRule -> csRule.getSubject());
    }
    
    /**
     * Returns the root of a reasoning tree generated by predicting
     * what would happen as a result of event e (forward chaining commonsense
     * rules).
     * @param e the event to be used to root the reasoning tree
     * @param debug true iff the method should narrate its actions (print debugging output) 
     */
    public ReasoningNode generatePredictions(Entity e, boolean narrate) {
        Function<Entity, List<Entity>> generateLeavesToExtend = EXTRACT_OBJECT_ENTITIES;
        Function<Entity, List<Entity>> generatePossibleExtensions = EXTRACT_SUBJECT_ENTITIES;
        return chainReasoning(e,
                leafEntity -> "hypothesize about what "+leafEntity.getObject().toEnglish()
                +" causes",
                narrate,
                generateLeavesToExtend,
                generatePossibleExtensions,
                csRule -> csRule.getObject());
    }
    
    /**
     * @return a set of "bridge" entities that link together personA and personB. A bridge
     * entity is a relation entity that occurs in the story that mentions both personA and personB.  
     */
    public Set<Entity> getBridgeEntitiesContaining(Entity personA, Entity personB) {
        Set<Entity> bridgeEntities = new HashSet<>();
        for (Entity event : story.getElements()) {
            if (event.isAnyOf(RELATION_CLASSES.stream().toArray(String[]::new))) {
                List<Entity> deepComponents = Util.getAllDeepComponents(event);
                if (deepComponents.contains(personA) && deepComponents.contains(personB)) {
                    bridgeEntities.add(event);
                }
            }
        }
        return bridgeEntities;
    }
    
    /**
     * Generates a List of PredictedRules by trying to connect the entities in the explanationTree and predictionTree.
     * Each entity is connected to every entity in its complement tree, and a set of bridge causes are generated
     * for every connection.
     * 
     * @param explanationTree explanation reasoning tree to generate effects from
     * @param predictionTree prediction reasoning tree to generate causes from
     * @return a list of PredictedRules where each PredictedRule joins a cause in the prediction tree to an effect
     * in the explanation tree, along with a set of bridge causes taken from background knowledge in the story. The 
     * explicit cause can be taken together with any combination of the bridge causes to reach the effect (or none -
     * just the explicit cause).
     */
    public List<PredictedRule> generatePredictedRules(ReasoningNode explanationTree, ReasoningNode predictionTree) {
        // TODO the same causeToPropose/effectToExplain can show up multiple times in the tree. prevent dupes using Pair class?
        // TODO remove requirement that there must be a bridge entity present?
        
        List<PredictedRule> predictedRules = new ArrayList<>();
        Map<Pair<Entity>, Set<Entity>> bridgeCache = new HashMap<>();
        
        for (ReasoningNode explanation : explanationTree) {
            Entity explanationEnt = explanation.getSubstitutedEntity();
            List<Entity> effectsToExplain;
            if (explanation.isRoot()) {
                effectsToExplain = Arrays.asList(explanationEnt);
            } else {
                effectsToExplain = EXTRACT_SUBJECT_ENTITIES.apply(explanationEnt);
            }
            for (ReasoningNode prediction : predictionTree) {
                Entity predictionEnt = prediction.getSubstitutedEntity();
                List<Entity> causesToPropose;
                if (prediction.isRoot()) {
                    causesToPropose = Arrays.asList(predictionEnt);
                } else {
                    causesToPropose = EXTRACT_OBJECT_ENTITIES.apply(predictionEnt);
                }
                                
                for (Entity effect : effectsToExplain) {
                    Set<Entity> effectEnts = new HashSet<>(Util.getAllDeepComponents(effect));
                    for (Entity cause : causesToPropose) {
                        Set<Entity> bridgeEntities = new HashSet<>();
                        Set<Entity> causeEnts = new HashSet<>(Util.getAllDeepComponents(cause));
                        for (Entity effectEnt : effectEnts) {
                            for (Entity causeEnt : causeEnts) {
                                Pair<Entity> curPair = new Pair<>(effectEnt, causeEnt);
                                if (!bridgeCache.containsKey(curPair)) {
                                    bridgeCache.put(curPair, getBridgeEntitiesContaining(effectEnt, causeEnt));
                                }
                                bridgeEntities.addAll(bridgeCache.get(curPair));
                            }
                        }
                        if (!bridgeEntities.isEmpty()) {
                            predictedRules.add(new PredictedRule(cause, prediction, bridgeEntities, effect, explanation));
                        }
                    }
                }
            }
        }
        
        return predictedRules;
    }        
}
